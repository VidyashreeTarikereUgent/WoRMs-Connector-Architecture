export type Configs<T, C> = {
    [P in keyof T]: Typed<C>;
};
export type Deserializers<T> = {
    [P in keyof T]?: (member: string) => T[P] | PromiseLike<T[P]>;
};
export type Serializers<T> = {
    [P in keyof T]?: (item: T[P]) => string | PromiseLike<string>;
};
export interface Writer<T> {
    push(item: T): Promise<void>;
    end(): Promise<void>;
}
export interface Stream<T> {
    lastElement?: T;
    end(): Promise<void>;
    data(listener: (t: T) => PromiseLike<void> | void): this;
    on(event: "data", listener: (t: T) => PromiseLike<void> | void): this;
    on(event: "end", listener: () => PromiseLike<void> | void): this;
}
export interface Typed<C> {
    type: string;
    config: C;
}
export interface StreamReaderFactory<C> {
    type: string;
    build: <T>(config: C, deserializer?: (message: string) => T | PromiseLike<T>) => Promise<Stream<T>>;
}
export interface StreamWriterFactory<C> {
    type: string;
    build: <T>(config: C, serializer?: (item: T) => string | PromiseLike<string>) => Promise<Writer<T>>;
}
export declare class ReaderFactoryBuilder<Cs> {
    private readonly inner;
    constructor(inner: StreamReaderFactory<Cs>[]);
    add<C>(factory: StreamReaderFactory<C>): ReaderFactoryBuilder<Cs | C>;
    build(): ReaderFactory<Cs>;
}
export declare class WriterFactoryBuilder<Cs> {
    private readonly inner;
    constructor(inner: StreamWriterFactory<Cs>[]);
    add<C>(factory: StreamWriterFactory<C>): WriterFactoryBuilder<Cs | C>;
    build(): WriterFactory<Cs>;
}
export declare function fromDeserializer<T>(des?: (message: string) => T | PromiseLike<T>): ((message: string) => T | PromiseLike<T>);
export declare class ReaderFactory<C> {
    private readonly factories;
    constructor(factories: StreamReaderFactory<C>[]);
    build<T>(config: Typed<C>, deserializer?: (message: string) => T | PromiseLike<T>): Promise<Stream<T>>;
    buildReader<T>(configs: Configs<T, C>, deserializers?: Deserializers<T>): Promise<{
        [P in keyof T]: Stream<T[P]>;
    }>;
}
export declare function fromSerializer<T>(ser?: (item: T) => string | PromiseLike<string>): ((item: T) => string | PromiseLike<string>);
export declare class WriterFactory<C> {
    private readonly factories;
    constructor(factories: StreamWriterFactory<C>[]);
    build<T>(config: Typed<C>, serializer?: (item: T) => string | PromiseLike<string>): Promise<Writer<T>>;
    buildReader<T>(configs: Configs<T, C>, serializers?: Serializers<T>): Promise<{
        [P in keyof T]: Writer<T[P]>;
    }>;
}
export type Handler<T> = (item: T) => Promise<void> | void;
export declare class SimpleStream<T> implements Stream<T> {
    private readonly dataHandlers;
    private readonly endHandlers;
    readonly disconnect: () => Promise<void>;
    lastElement?: T | undefined;
    constructor(onDisconnect?: () => Promise<void>);
    data(listener: Handler<T>): this;
    push(data: T): Promise<void>;
    end(): Promise<void>;
    on(event: "data", listener: Handler<T>): this;
    on(event: "end", listener: Handler<void>): this;
}
//# sourceMappingURL=types.d.ts.map