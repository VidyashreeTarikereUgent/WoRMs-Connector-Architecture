"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GeospatialBucketizer = exports.GeospatialBucketizerFactory = void 0;
const bucketizer_core_1 = require("@treecg/bucketizer-core");
const bucketizer_core_2 = require("@treecg/bucketizer-core");
const types_1 = require("@treecg/types");
const SlippyMaps_1 = require("./utils/SlippyMaps");
class GeospatialBucketizerFactory {
    constructor() {
        this.type = "geospatial";
    }
    build(config, state) {
        return GeospatialBucketizer.build(config, state);
    }
    ldConfig(quads, subject) {
        const out = (0, bucketizer_core_1.parseBucketizerExtCoreOptions)(quads, subject);
        if (out.type.value === types_1.LDES.custom(this.type)) {
            return Object.assign(out, { 'zoom': parseInt((0, bucketizer_core_1.findProperty)(quads, subject, types_1.LDES.terms.custom("zoomLevel")).value) });
        }
        else {
            return;
        }
    }
}
exports.GeospatialBucketizerFactory = GeospatialBucketizerFactory;
class GeospatialBucketizer extends bucketizer_core_2.BucketizerCoreExt {
    constructor(bucketizerOptions) {
        super(bucketizerOptions);
        this.createBuckets = (propertyPathObjects, newRelations) => {
            const buckets = [];
            propertyPathObjects.forEach(term => {
                const tilesMap = this.slippyMaps.calculateTiles(term);
                tilesMap.forEach((values, x) => {
                    values.forEach(y => {
                        const leafNodePath = `${this.zoomLevel}/${x}/${y}`;
                        const columnPath = `${this.zoomLevel}/${x}`;
                        const pageSize = this.options.pageSize;
                        const wktString = this.slippyMaps.getTileBoundingBoxWktString(x, y, this.zoomLevel);
                        let metadata;
                        if (this.tileMetadataMap.has(leafNodePath)) {
                            metadata = this.tileMetadataMap.get(leafNodePath);
                            if (metadata.memberCounter === pageSize) {
                                this.updateTileMetadata(leafNodePath, columnPath, wktString, metadata, newRelations);
                            }
                        }
                        else {
                            metadata = this.createTileMetadata(leafNodePath, columnPath, wktString, newRelations);
                            // Update hypermedia controls for root (extend polygon with bounding box of new tile)
                            const rootHypermediaControls = this.getHypermediaControls(this.getRoot());
                            const columnRelationParameters = rootHypermediaControls.find(parameterObject => parameterObject.nodeId === columnPath);
                            if (columnRelationParameters) {
                                const polygon = columnRelationParameters.value[0];
                                const updatedPolygon = this.slippyMaps.mergePolygons(polygon.value, wktString);
                                columnRelationParameters.value = [
                                    this.factory.literal(updatedPolygon, this.factory.namedNode('http://www.opengis.net/ont/geosparql#wktLiteral')),
                                ];
                            }
                            else {
                                const parameters = this.createRelationParameters(columnPath, wktString);
                                this.addHypermediaControls(this.getRoot(), parameters);
                                newRelations.push([this.getRoot(), parameters]);
                            }
                        }
                        buckets.push(`${leafNodePath}-${metadata.pageNumber}`);
                        metadata.memberCounter++;
                    });
                });
            });
            return buckets;
        };
        this.createRelationParameters = (targetNode, value) => ({
            nodeId: targetNode,
            type: types_1.RelationType.GeospatiallyContains,
            value: [this.factory.literal(value, this.factory.namedNode('http://www.opengis.net/ont/geosparql#wktLiteral'))],
        });
        this.createTileMetadata = (tilePath, columnPath, wktString, newRelations) => {
            const metadata = {
                pageNumber: 0,
                memberCounter: 0,
            };
            this.tileMetadataMap.set(tilePath, metadata);
            // Update column hypermedia controls
            this.updateColumnHypermediaControls(columnPath, tilePath, wktString, metadata.pageNumber, newRelations);
            return metadata;
        };
        this.updateTileMetadata = (tilePath, columnPath, wktString, metadata, newRelations) => {
            metadata.pageNumber++;
            metadata.memberCounter = 0;
            // Add new page to column hypermedia controls
            this.updateColumnHypermediaControls(columnPath, tilePath, wktString, metadata.pageNumber, newRelations);
        };
        this.updateColumnHypermediaControls = (columnPath, tilePath, wktString, pageNumber, newRelations) => {
            let columnHypermediaControls = this.getHypermediaControls(columnPath);
            const paginatedTilePath = `${tilePath}-${pageNumber}`;
            if (!columnHypermediaControls) {
                columnHypermediaControls = [];
            }
            const parameters = this.createRelationParameters(paginatedTilePath, wktString);
            this.addHypermediaControls(columnPath, parameters);
            newRelations.push([columnPath, parameters]);
        };
        this.zoomLevel = bucketizerOptions.zoom;
        this.slippyMaps = new SlippyMaps_1.SlippyMaps(bucketizerOptions.zoom);
        this.tileMetadataMap = new Map();
        this.setHypermediaControls(this.getRoot());
    }
    static build(bucketizerOptions, state) {
        const bucketizer = new GeospatialBucketizer(bucketizerOptions);
        if (state) {
            bucketizer.importState(state);
        }
        return bucketizer;
    }
    exportState() {
        const state = super.exportState();
        state.zoomLevel = this.zoomLevel;
        state.tileMetadataMap = Array.from(this.tileMetadataMap.entries());
        return state;
    }
    importState(state) {
        super.importState(state);
        this.zoomLevel = state.zoomLevel;
        this.tileMetadataMap = new Map(state.tileMetadataMap);
    }
}
exports.GeospatialBucketizer = GeospatialBucketizer;
