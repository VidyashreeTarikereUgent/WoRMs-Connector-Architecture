"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SlippyMaps = void 0;
const turf = require('@turf/turf');
const dissolve = require('geojson-dissolve');
const bbox = require('slippy-bbox');
const { parse, stringify } = require('wkt');
class SlippyMaps {
    constructor(zoomLevel) {
        this.zoomLevel = zoomLevel;
    }
    calculateTiles(term) {
        const geoJson = this.toGeoJson(term);
        const coordinates = geoJson.type.toLowerCase() === 'point' ?
            [geoJson.coordinates] :
            this.flattenArray(geoJson.coordinates);
        // Map with X as key and Y values in array
        const tilesMap = new Map();
        coordinates.forEach(coordinate => {
            const latitude = Number.parseInt(coordinate[1], 10);
            const longitude = Number.parseInt(coordinate[0], 10);
            const x = this.longitudeToTile(longitude);
            const y = this.latitudeToTile(latitude);
            const leafNodes = tilesMap.get(x);
            if (!leafNodes || !leafNodes.includes(y)) {
                const updatedLeafNodes = leafNodes === undefined ? [y] : [...leafNodes, y];
                tilesMap.set(x, updatedLeafNodes);
            }
        });
        return tilesMap;
    }
    toGeoJson(term) {
        const literal = term;
        switch (literal.datatype.value) {
            case 'http://www.opengis.net/ont/geosparql#wktLiteral':
                return this.wktToGeoJson(literal.value);
            default:
                throw new Error(`[GeospatialBucketizer]: geospatial datatype not supported (only wkt).`);
        }
    }
    getTileBoundingBoxWktString(x, y, zoom) {
        const boundingBox = bbox(x, y, zoom);
        const geometry = turf.bboxPolygon(boundingBox).geometry;
        return stringify(geometry);
    }
    mergePolygons(polygonWktStringA, polygonWktStringB) {
        const geoA = parse(polygonWktStringA);
        const geoB = parse(polygonWktStringB);
        return stringify(dissolve([geoA, geoB]));
    }
    wktToGeoJson(geoString) {
        if (geoString.startsWith('<')) {
            geoString = geoString.slice(geoString.indexOf('>') + 1).trim();
        }
        return parse(geoString);
    }
    longitudeToTile(longitude) {
        return Math.floor((longitude + 180) / 360 * 2 ** this.zoomLevel);
    }
    latitudeToTile(latitude) {
        return Math.floor((1 - Math.log(Math.tan(latitude * Math.PI / 180) +
            1 / Math.cos(latitude * Math.PI / 180)) / Math.PI) / 2 * 2 ** this.zoomLevel);
    }
    flattenArray(coordinates) {
        // We need to flatten each array to a 2D array
        while (Array.isArray(coordinates[0][0])) {
            coordinates = coordinates.flat(1);
        }
        return coordinates;
    }
}
exports.SlippyMaps = SlippyMaps;
