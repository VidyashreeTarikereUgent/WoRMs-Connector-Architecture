"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ingest = void 0;
const types_1 = require("@treecg/types");
const mongodb_1 = require("mongodb");
const n3_1 = require("n3");
const process_1 = require("process");
const winston_1 = __importDefault(require("winston"));
const fragmentHelper_1 = require("./fragmentHelper");
const consoleTransport = new winston_1.default.transports.Console();
const logger = winston_1.default.createLogger({
    format: winston_1.default.format.combine(winston_1.default.format.colorize({ level: true }), winston_1.default.format.simple()), transports: [consoleTransport]
});
consoleTransport.level = process.env.LOG_LEVEL || "debug";
// Set<String> yikes!
function filterMember(quads, id, blacklist = [], done) {
    const d = done === undefined ? new Set() : done;
    const quadIsBlacklisted = (q) => blacklist.some(b => b(q, id));
    d.add(id.value);
    const out = quads.filter(q => q.subject.equals(id) && !quadIsBlacklisted(q));
    const newObjects = quads.filter(q => q.subject.equals(id) && !quadIsBlacklisted(q)).map(q => q.object).filter(o => o.termType === "BlankNode" || o.termType === "NamedNode");
    for (let id of newObjects) {
        if (d.has(id.value))
            continue;
        out.push(...filterMember(quads, id, blacklist, d));
    }
    const newSubjects = quads.filter(q => q.object.equals(id) && !quadIsBlacklisted(q)).map(q => q.subject).filter(o => o.termType === "BlankNode" || o.termType === "NamedNode");
    for (let id of newSubjects) {
        if (d.has(id.value))
            continue;
        out.push(...filterMember(quads, id, blacklist, d));
    }
    return out;
}
function maybe_parse(data) {
    if (typeof data === 'string' || data instanceof String) {
        const parse = new n3_1.Parser();
        return parse.parse(data);
    }
    else {
        return data;
    }
}
function getRelatedBuckets(quads, bucket, done) {
    const set = [];
    const get = (q) => {
        if (done.has(q.value)) {
            return;
        }
        done.add(q.value);
        set.push(q);
        // Find forward relations
        quads
            .filter(x => x.subject.equals(q) && x.predicate.equals(types_1.SDS.terms.relation)).map(x => x.object)
            .flatMap(bn => quads.filter(q => q.subject.equals(bn) && q.predicate.equals(types_1.SDS.terms.relationBucket))
            .map(x => x.object)).forEach(get);
        // Find backwards relations
        quads.filter(x => x.object.equals(q) && x.predicate.equals(types_1.SDS.terms.relationBucket)).map(x => x.subject)
            .flatMap(bn => quads.filter(q => q.object.equals(bn) && q.predicate.equals(types_1.SDS.terms.relation))
            .map(x => x.subject)).forEach(get);
    };
    get(bucket);
    return set;
}
function parseBool(bo) {
    if (!bo) {
        return false;
    }
    else {
        const bos = bo.toLowerCase();
        return bos === "t" || bos === "true" || bos === "1";
    }
}
function gatherBuckets(buckets, data, subject, stream, found) {
    var _a, _b, _c, _d;
    console.log("Immutable quads");
    console.log(data.filter(x => x.predicate.equals(types_1.SDS.terms.custom("immutable"))));
    for (let bucket of getRelatedBuckets(data, subject, found)) {
        const isRoot = (_a = data.find(q => q.subject.equals(bucket) && q.predicate.equals(types_1.SDS.terms.custom("isRoot")))) === null || _a === void 0 ? void 0 : _a.object.value;
        const immutable = (_b = data.find(q => q.subject.equals(bucket) && q.predicate.equals(types_1.SDS.terms.custom("immutable")))) === null || _b === void 0 ? void 0 : _b.object.value;
        const b = {
            root: isRoot === "true",
            id: bucket.value,
            relations: [],
            stream,
            immutable: parseBool(immutable),
        };
        const relations = data.filter(q => q.subject.equals(bucket) && q.predicate.equals(types_1.SDS.terms.relation)).map(x => x.object);
        for (let rel of relations) {
            const relObj = data.filter(q => q.subject.equals(rel));
            const type = relObj.find(q => q.predicate.equals(types_1.SDS.terms.relationType)).object.value;
            const target = relObj.find(q => q.predicate.equals(types_1.SDS.terms.relationBucket)).object.value;
            const path = (_c = relObj.find(q => q.predicate.equals(types_1.SDS.terms.relationPath))) === null || _c === void 0 ? void 0 : _c.object.value;
            const value = (_d = relObj.find(q => q.predicate.equals(types_1.SDS.terms.relationValue))) === null || _d === void 0 ? void 0 : _d.object.value;
            b.relations.push({ type, bucket: target, path, value });
        }
        buckets.push(b);
    }
}
function gatherRecords(data, timestampPaths) {
    var _a, _b;
    const out = [];
    for (let recordId of data.filter(q => q.predicate.equals(types_1.SDS.terms.payload)).map(x => x.subject)) {
        const stream = (_a = data.find(q => q.subject.equals(recordId) && q.predicate.equals(types_1.SDS.terms.stream))) === null || _a === void 0 ? void 0 : _a.object.value;
        if (!stream) {
            console.error("Found SDS record without a stream!");
            continue;
        }
        const payload = data.find(q => q.subject.equals(recordId) && q.predicate.equals(types_1.SDS.terms.payload)).object;
        const buckets = data.filter(q => q.subject.equals(recordId) && q.predicate.equals(types_1.SDS.terms.bucket)).map(x => x.object);
        const tPath = timestampPaths[stream];
        const timestampValue = tPath ? (_b = data.find(q => q.subject.equals(payload) && q.predicate.value === tPath)) === null || _b === void 0 ? void 0 : _b.object.value : undefined;
        out.push({
            stream, payload, buckets, timestampValue
        });
    }
    return out;
}
const addedMembers = new Set();
function addDataRecord(updateRecords, record, quads, collection) {
    return __awaiter(this, void 0, void 0, function* () {
        const value = record.payload.value;
        if (addedMembers.has(value)) {
            return;
        }
        addedMembers.add(value);
        const present = (yield collection.count({ id: value })) > 0;
        if (present)
            return;
        const member = filterMember(quads, record.payload, [(q) => q.predicate.equals(types_1.SDS.terms.payload)]);
        const ser = new n3_1.Writer().quadsToString(member);
        updateRecords.push({ id: value, data: ser, timestamp: record.timestampValue });
    });
}
const setRoots = new Set();
const immutables = new Set();
function addBucket(bucket, collection) {
    return __awaiter(this, void 0, void 0, function* () {
        // Handle root setting
        if (bucket.root && !setRoots.has(bucket.stream)) {
            setRoots.add(bucket.stream);
            yield collection.updateOne({ streamId: bucket.stream, id: bucket.id }, { $set: { root: true } }, { upsert: true });
        }
        if (bucket.immutable && !immutables.has(bucket.id)) {
            immutables.add(bucket.id);
            yield collection.updateOne({ streamId: bucket.stream, id: bucket.id }, { $set: { immutable: true } }, { upsert: true });
        }
        for (let newRelation of bucket.relations) {
            yield collection.updateOne({ streamId: bucket.stream, id: bucket.id }, { "$push": { relations: newRelation } }, { "upsert": true });
        }
    });
}
function setup_metadata(metadata, metaCollection, setTimestamp, onClose) {
    return __awaiter(this, void 0, void 0, function* () {
        let ingestMetadata = true;
        metadata.on("end", () => {
            ingestMetadata = false;
            return onClose();
        });
        const dbFragmentations = yield metaCollection.find({ "type": "fragmentation" })
            .map(entry => { console.log("Found entry", entry); return { id: entry.id, quads: new n3_1.Parser().parse(entry.value) }; })
            .toArray();
        logger.debug(`Found ${dbFragmentations.length} fragmentations (${dbFragmentations.map(x => x.id.value)})`);
        const handleMetadata = (meta) => __awaiter(this, void 0, void 0, function* () {
            var _a, _b;
            meta = maybe_parse(meta);
            if (!ingestMetadata) {
                logger.error("Cannot handle metadata, mongo is closed");
                return;
            }
            const streams = meta.filter(q => q.predicate.equals(types_1.RDF.terms.type) && q.object.equals(types_1.SDS.terms.Stream)).map(q => q.subject);
            for (let streamId of streams) {
                const streamMember = filterMember(meta, streamId, [
                    (q, id) => q.predicate.equals(types_1.PROV.terms.used) && q.object.equals(id),
                    (q, id) => q.predicate.equals(types_1.SDS.terms.dataset) && q.object.equals(id),
                ]);
                const datasetId = (_a = streamMember.find(q => q.subject.equals(streamId) && q.predicate.equals(types_1.SDS.terms.dataset))) === null || _a === void 0 ? void 0 : _a.object;
                if (datasetId) {
                    const timestampPathObject = (_b = streamMember.find(q => q.subject.equals(datasetId) && q.predicate.equals(types_1.LDES.terms.timestampPath))) === null || _b === void 0 ? void 0 : _b.object;
                    if (timestampPathObject) {
                        setTimestamp(streamId.value, timestampPathObject.value);
                    }
                }
                const ser = new n3_1.Writer().quadsToString(streamMember);
                yield metaCollection.updateOne({ "type": types_1.SDS.Stream, "id": streamId.value }, { $set: { value: ser } }, { upsert: true });
            }
        });
        metadata.data(handleMetadata);
        if (metadata.lastElement) {
            handleMetadata(metadata.lastElement);
        }
    });
}
function ingest(data, metadata, metacollection, dataCollection, indexCollectionName, mUrl, maxSize = 10) {
    return __awaiter(this, void 0, void 0, function* () {
        const url = mUrl || process_1.env.DB_CONN_STRING || "mongodb://localhost:27017/ldes";
        const mongo = yield new mongodb_1.MongoClient(url).connect();
        const db = mongo.db();
        logger.debug("Connected");
        const streamTimestampPaths = {};
        let ingestMetadata = true;
        let ingestData = true;
        let closed = false;
        const closeMongo = () => {
            if (!ingestMetadata && !ingestData && !closed) {
                logger.info("Closing mongo");
                closed = true;
                return mongo.close();
            }
        };
        data.on("end", () => {
            ingestData = false;
            return closeMongo();
        });
        console.log("Done setting up end callbacks");
        setup_metadata(metadata, db.collection(metacollection), (k, v) => streamTimestampPaths[k] = v, closeMongo);
        console.log("Attached metadata handler");
        const memberCollection = db.collection(dataCollection);
        const indexCollection = db.collection(indexCollectionName);
        const pushMemberToDB = (record) => __awaiter(this, void 0, void 0, function* () {
            const bs = record.buckets;
            if (bs.length === 0) {
                yield indexCollection.updateOne({ root: true, streamId: record.stream, id: "" }, { $push: { members: record.payload.value } }, { upsert: true });
            }
            else {
                for (let bucket of bs) {
                    yield indexCollection.updateOne({ streamId: record.stream, id: bucket.value }, { $push: { members: record.payload.value } }, { upsert: true });
                }
            }
        });
        const pushTimstampMemberToDB = (record) => __awaiter(this, void 0, void 0, function* () {
            const bs = record.buckets;
            if (bs.length === 0) {
                yield (0, fragmentHelper_1.handleTimestampPath)("", record.stream, streamTimestampPaths[record.stream], record.timestampValue, record.payload.value, indexCollection, maxSize);
            }
            else {
                for (let bucket of bs) {
                    yield (0, fragmentHelper_1.handleTimestampPath)(bucket.value, record.stream, streamTimestampPaths[record.stream], record.timestampValue, record.payload.value, indexCollection, maxSize);
                }
            }
        });
        data.data((input) => __awaiter(this, void 0, void 0, function* () {
            const data = maybe_parse(input);
            if (!ingestData) {
                logger.error("Cannot handle data, mongo is closed");
                return;
            }
            const records = gatherRecords(data, streamTimestampPaths);
            console.log(`ingest: Handling ${records.length} records`);
            const updateData = [];
            for (let r of records) {
                yield addDataRecord(updateData, r, data, memberCollection);
            }
            if (updateData.length > 0) {
                yield memberCollection.insertMany(updateData);
            }
            for (let r of records) {
                yield (r.timestampValue ? pushTimstampMemberToDB(r) : pushMemberToDB(r));
            }
            const found = new Set();
            const buckets = [];
            for (let r of records) {
                r.buckets.forEach(b => gatherBuckets(buckets, data, b, r.stream, found));
            }
            for (let bucket of buckets) {
                yield addBucket(bucket, indexCollection);
            }
        }));
        console.log("Attached data handler");
    });
}
exports.ingest = ingest;
