"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BucketizerCoreExt = exports.BucketizerCore = exports.parseBucketizerExtCoreOptions = exports.parseBucketizerCoreOptions = exports.findProperty = void 0;
const types_1 = require("@treecg/types");
const types_2 = require("@treecg/types");
const N3 = require("n3");
const rdf_data_factory_1 = require("rdf-data-factory");
function findProperty(quads, subject, predicate) {
    const quad = quads.find(q => q.subject.value === subject.value && q.predicate.value === predicate.value);
    if (!quad) {
        throw "Not found!";
    }
    return quad.object;
}
exports.findProperty = findProperty;
function parseBucketizerCoreOptions(quads, subject) {
    const out = {};
    try {
        out.bucketProperty = findProperty(quads, subject, types_1.LDES.terms.bucketProperty).value;
    }
    catch (e) { }
    try {
        const pageSize = findProperty(quads, subject, types_1.LDES.terms.custom("pageSize")).value;
        out.pageSize = parseInt(pageSize);
    }
    catch (e) {
        out.pageSize = 50;
    }
    out.type = findProperty(quads, subject, types_1.LDES.terms.bucketType);
    return out;
}
exports.parseBucketizerCoreOptions = parseBucketizerCoreOptions;
function loop_list(quads, subject) {
    var _a;
    let current = subject;
    const out = [];
    while (!current.equals(types_2.RDF.terms.nil)) {
        const next = quads.find(q => q.subject.equals(current) && q.predicate.equals(types_2.RDF.terms.rest));
        if (!next)
            return;
        const value = (_a = quads.find(q => q.subject.equals(current) && q.predicate.equals(types_2.RDF.terms.first))) === null || _a === void 0 ? void 0 : _a.object;
        if (!value)
            return;
        out.push(value);
        current = next.object;
    }
    return out;
}
function parseBucketizerExtCoreOptions(quads, subject) {
    var _a;
    const options = parseBucketizerCoreOptions(quads, subject);
    try {
        options.root = findProperty(quads, subject, types_1.LDES.terms.custom("isBucketRoot")).value;
    }
    catch (e) {
        options.root = 'root';
    }
    const path = (_a = quads.find(q => q.subject.value === subject.value && q.predicate.equals(types_2.TREE.terms.path))) === null || _a === void 0 ? void 0 : _a.object;
    if (!path) {
        throw "Predicate tree:path not found!";
    }
    const list = loop_list(quads, path);
    const property = (list ? list : [path]);
    options.propertyPath = property;
    return options;
}
exports.parseBucketizerExtCoreOptions = parseBucketizerExtCoreOptions;
class BucketizerCore {
    constructor(options) {
        this.factory = new rdf_data_factory_1.DataFactory();
        this.bucketHypermediaControlsMap = new Map();
        this.logger = (0, types_2.getLogger)('bucketizer');
        if (!options.pageSize) {
            this.logger.warn(`No page size provided. Page size is set to default value = 50`);
            options.pageSize = 50;
        }
        // This is safe, we gave default values to fields of BucketizerCoreOptions
        this.options = options;
    }
    bucketNode(id) {
        return this.factory.namedNode(id);
    }
    getRoot() {
        return "";
    }
    getBucketHypermediaControlsMap() {
        return this.bucketHypermediaControlsMap;
    }
    getHypermediaControls(bucket, create = false) {
        const out = this.bucketHypermediaControlsMap.get(bucket);
        if (create && out === undefined) {
            const newOut = [];
            this.bucketHypermediaControlsMap.set(bucket, newOut);
            return newOut;
        }
        return out;
    }
    expandRelation(from, to) {
        //
        //  <bucket1> sds:relation [
        //    sds:relationType tree:GreaterThanRelation ;
        //    sds:relationBucket <bucket2> ;
        //    sds:relationPath <thing> ;
        //    sds:relationValue 1;
        //    sds:relationPath ex:x
        //  ] .
        //
        const sourceId = this.bucketNode(from);
        const targetId = this.bucketNode(to.nodeId);
        const relationId = this.factory.blankNode();
        const out = [];
        out.push(this.factory.quad(sourceId, types_2.SDS.terms.custom('relation'), relationId));
        out.push(this.factory.quad(relationId, types_2.SDS.terms.custom('relationType'), this.factory.namedNode(to.type)));
        out.push(this.factory.quad(relationId, types_2.SDS.terms.custom('relationBucket'), targetId));
        for (const value of to.value || []) {
            out.push(this.factory.quad(relationId, types_2.SDS.terms.custom('relationValue'), value));
        }
        if (to.path) {
            out.push(this.factory.quad(relationId, types_2.SDS.terms.custom('relationPath'), to.path));
        }
        // Add information about root buckets
        if (from === this.getRoot()) {
            out.push(this.factory.quad(sourceId, types_2.SDS.terms.custom('isRoot'), this.factory.literal("true")));
        }
        if (to.nodeId === this.getRoot()) {
            out.push(this.factory.quad(targetId, types_2.SDS.terms.custom('isRoot'), this.factory.literal("true")));
        }
        return out;
    }
    createSDSRecord(id, buckets) {
        const out = [];
        const sdsId = this.factory.blankNode();
        out.push(this.factory.quad(sdsId, types_2.SDS.terms.custom('payload'), id));
        for (const bucket of buckets) {
            out.push(this.factory.quad(sdsId, types_2.SDS.terms.custom('bucket'), this.bucketNode(bucket)));
        }
        return out;
    }
    setHypermediaControls(bucket, ...controls) {
        if (this.bucketHypermediaControlsMap.get(bucket) != undefined) {
            this.logger.warn(`overriding hypermediacontrols for bucket ${bucket}`);
        }
        this.bucketHypermediaControlsMap.set(bucket, controls);
    }
    addHypermediaControls(bucket, ...newControls) {
        const controls = this.getHypermediaControls(bucket, true);
        controls.push(...newControls);
    }
    exportState() {
        const bucketizerOptions = this.options;
        return {
            bucketizerOptions,
            hypermediaControls: Array.from(this.bucketHypermediaControlsMap.entries()),
        };
    }
    importState(state) {
        this.options = state.bucketizerOptions;
        this.bucketHypermediaControlsMap = new Map(state.hypermediaControls);
    }
}
exports.BucketizerCore = BucketizerCore;
function extSetDefaults(options) {
    if (options.propertyPath == undefined) {
        throw 'expected propertyPath in options but found undefined';
    }
    options.root = options.root || 'root';
    return options;
}
class BucketizerCoreExt extends BucketizerCore {
    constructor(bucketizerOptions) {
        super(extSetDefaults(bucketizerOptions));
        /**
           * Returns the RDF Term that matches the property path and will be used to create a bucket triple
           * @param memberQuads an array of quads representing a member
           * @param memberId identifier of the member
           * @returns an RDF Term
           */
        this.extractPropertyPathObject = (memberQuads, memberId, properties = this.propertyPathPredicates) => {
            const memberTerm = typeof memberId === 'string' ? this.factory.namedNode(memberId) : memberId;
            if (properties.length === 0) {
                return [memberTerm];
            }
            const head = properties[0];
            return memberQuads
                .filter(quad => quad.subject.equals(memberTerm))
                .filter(quad => quad.predicate.equals(head))
                .flatMap(member => this.extractPropertyPathObject(memberQuads, member.object, properties.slice(1)));
        };
        this.fallback = (newRelations) => {
            const pageSize = this.options.pageSize;
            if (pageSize && this.bucketlessPageMemberCounter === pageSize) {
                this.bucketlessPageNumber++;
                this.bucketlessPageMemberCounter = 0;
            }
            const rootHypermediaControls = this.getHypermediaControls(this.options.root);
            if (!rootHypermediaControls || !rootHypermediaControls.some(parameter => parameter.nodeId === `bucketless-${this.bucketlessPageNumber}`)) {
                const relationParameters = {
                    nodeId: `bucketless-${this.bucketlessPageNumber}`,
                    type: types_2.RelationType.Relation,
                };
                newRelations.push([`${this.getRoot()}`, relationParameters]);
                this.setHypermediaControls(`${this.getRoot()}`, relationParameters);
            }
            this.bucketlessPageMemberCounter++;
            return `bucketless-${this.bucketlessPageNumber}`;
        };
        this.propertyPathPredicates = [];
        this.bucketlessPageNumber = 0;
        this.bucketlessPageMemberCounter = 0;
        this.setPropertyPathQuads(this.options.propertyPath);
    }
    getPropertyPathMember() {
        if (this.propertyPathPredicates.length === 1) {
            return {
                id: this.propertyPathPredicates[0],
                quads: [],
            };
        }
        const quads = [];
        let id = types_2.RDF.terms.nil;
        for (const pred of this.propertyPathPredicates) {
            const newId = this.factory.blankNode();
            quads.push(this.factory.quad(newId, types_2.RDF.terms.rest, id), this.factory.quad(newId, types_2.RDF.terms.first, pred));
            id = newId;
        }
        return {
            quads, id,
        };
    }
    setPropertyPathQuads(propertyPath) {
        let quads;
        if (Array.isArray(propertyPath)) {
            this.propertyPathPredicates = propertyPath;
            return;
        }
        else {
            const fullPath = `_:b0 <https://w3id.org/tree#path> ${propertyPath} .`;
            quads = new N3.Parser().parse(fullPath);
        }
        let source = quads.find(quad => quad.predicate.value === types_2.TREE.path).object;
        const hasNext = quads.find(quad => quad.subject.equals(source));
        if (hasNext) {
            while (!source.equals(types_2.RDF.terms.nil)) {
                const listNodes = quads.filter(quad => quad.subject.equals(source));
                source = listNodes.find(quad => quad.predicate.equals(types_2.RDF.terms.rest)).object;
                const item = listNodes.find(quad => quad.predicate.equals(types_2.RDF.terms.first)).object;
                this.propertyPathPredicates.push(item);
            }
        }
        else {
            this.propertyPathPredicates.push(source);
        }
    }
    /**
       * Returns triples indicating the buckets in which the version object must be place
       * and information about these bucket and how they relate
       *
       * Note: This information about buckets is stateful, a previous bucket may be referred to.
       */
    bucketize(quads, memberId) {
        const propertyPathObjects = this.extractPropertyPathObject(quads, memberId);
        const newRelations = [];
        const immutables = [];
        const bucketNodes = [];
        if (propertyPathObjects.length <= 0) {
            this.logger.warn(`No matches found for property path "${this.options.propertyPath}" in member "${memberId}". Applying fallback.`);
            const bucketNode = this.fallback(newRelations);
            bucketNodes.push(bucketNode);
        }
        else {
            try {
                const buckets = this.createBuckets(propertyPathObjects, newRelations, immutables);
                bucketNodes.push(...buckets);
            }
            catch (error) {
                this.logger.error(`Error while creating the buckets for member ${memberId}. Applying fallback.`);
                this.logger.info(error);
                bucketNodes.push(this.fallback(newRelations));
            }
        }
        const out = [
            ...immutables.map(x => this.factory.quad(this.factory.namedNode(x), types_2.SDS.terms.custom("immutable"), this.factory.literal("true"))),
            ...newRelations.flatMap(([source, rel]) => this.expandRelation(source, rel)),
            ...this.createSDSRecord(this.factory.namedNode(memberId), bucketNodes),
        ];
        const propMember = this.getPropertyPathMember();
        if (newRelations.some(([_, rel]) => (rel === null || rel === void 0 ? void 0 : rel.path) && rel.path.equals(propMember.id))) {
            out.push(...propMember.quads);
        }
        return out;
    }
    getPropertyPathPredicates() {
        return this.propertyPathPredicates;
    }
    exportState() {
        const state = super.exportState();
        return Object.assign(state, {
            propertyPathPredicates: this.propertyPathPredicates,
            bucketizerOptions: this.options,
            bucketlessPageNumber: this.bucketlessPageNumber,
            bucketlessPageMemberCounter: this.bucketlessPageMemberCounter,
        });
    }
    getRoot() {
        return this.options.root || "root";
    }
    importState(state) {
        super.importState(state);
        this.propertyPathPredicates = state.propertyPathPredicates;
        this.bucketlessPageNumber = state.bucketlessPageNumber;
        this.bucketlessPageMemberCounter = state.bucketlessPageMemberCounter;
    }
}
exports.BucketizerCoreExt = BucketizerCoreExt;
