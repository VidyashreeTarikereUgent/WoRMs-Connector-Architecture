"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createBucketizerLD = exports.getValidShape = exports.createBucketizer = void 0;
const promises_1 = require("fs/promises");
const types_1 = require("@treecg/types");
const N3 = require("n3");
const Validator = require("rdf-validate-shacl");
const __1 = require("..");
function createBucketizer(input, state) {
    return __1.FACTORY.build(input, input.type, state);
}
exports.createBucketizer = createBucketizer;
async function loadTurtle(location) {
    const content = await (0, promises_1.readFile)(location, { encoding: 'utf-8' });
    const parser = new N3.Parser();
    const quads = parser.parse(content);
    return new N3.Store(quads);
}
async function getValidShape(ld, subject) {
    const shapeData = await loadTurtle(`${__dirname}/shape.ttl`);
    const validator = new Validator(shapeData);
    const data = new N3.Store(ld);
    const factory = N3.DataFactory;
    const subjects = data.getSubjects(types_1.RDF.terms.type, types_1.LDES.terms.BucketizeStrategy, null);
    const shape = factory.namedNode('http://schema.org/BucketizeShape');
    for (const sub of subjects) {
        if (subject && sub.value !== subject.value) {
            continue;
        }
        validator.validate(data);
        if (validator.nodeConformsToShape(sub, shape)) {
            return sub;
        }
    }
}
exports.getValidShape = getValidShape;
async function createBucketizerLD(ld, subject, state) {
    const validShape = await getValidShape(ld, subject);
    if (!validShape) {
        throw new Error('No valid shape found!');
    }
    return __1.FACTORY.buildLD(ld, validShape, state);
}
exports.createBucketizerLD = createBucketizerLD;
