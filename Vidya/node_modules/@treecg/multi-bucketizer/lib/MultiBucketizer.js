"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MultiBucketizer = exports.MultiBucketizerFactory = void 0;
const bucketizer_core_1 = require("@treecg/bucketizer-core");
const types_1 = require("@treecg/types");
const rdf_data_factory_1 = require("rdf-data-factory");
;
class MultiBucketizerFactory {
    constructor(factory) {
        this.type = "multi";
        this.factory = factory;
    }
    build(config, state) {
        return MultiBucketizer.build(config, this.factory, state);
    }
    ldConfig(quads, subject) {
        if ((0, bucketizer_core_1.findProperty)(quads, subject, types_1.LDES.terms.bucketType).value !== types_1.LDES.custom(this.type)) {
            return;
        }
        const configs = [];
        let current = (0, bucketizer_core_1.findProperty)(quads, subject, types_1.LDES.terms.custom("configs"));
        try {
            while (current.value !== types_1.RDF.nil) {
                // Find current config
                const currentSubject = (0, bucketizer_core_1.findProperty)(quads, current, types_1.RDF.terms.first);
                configs.push(this.factory.getConfig(quads, currentSubject));
                // Find next current
                current = (0, bucketizer_core_1.findProperty)(quads, current, types_1.RDF.terms.rest);
            }
        }
        catch (ex) {
            // This is fine
        }
        return { configs };
    }
}
exports.MultiBucketizerFactory = MultiBucketizerFactory;
class MultiBucketizer {
    constructor() {
        this.builders = [];
        this.factory = new rdf_data_factory_1.DataFactory();
    }
    static build(config, factory, _state) {
        const out = new MultiBucketizer();
        for (let c of config.configs) {
            out.builders.push(() => factory.build(c.config, c.type));
        }
        out.bucketizers = { current: out.builders[0](), children: {} };
        return out;
    }
    bucketize(quads, memberId) {
        return this.bucketizePart(quads, memberId, this.bucketizers, this.builders.slice(1));
    }
    extractBucketId(quads, memberId) {
        var _a, _b;
        let sdsRecordId = (_a = quads.find(x => x.predicate.value === types_1.SDS.payload && x.object.value === memberId)) === null || _a === void 0 ? void 0 : _a.subject;
        if (!sdsRecordId) {
            throw "Expected a SDS record";
        }
        let bucketId = (_b = quads.find(x => x.subject.equals(sdsRecordId) && x.predicate.value === types_1.SDS.bucket)) === null || _b === void 0 ? void 0 : _b.object;
        if (!bucketId) {
            throw "Expected a Bucket value";
        }
        return bucketId;
    }
    bucketizePart(quads, memberId, bucketizers, builders) {
        var _a;
        let extras = bucketizers.current.bucketize(quads, memberId);
        // Recursion!
        if (builders.length > 0) {
            // Find target bucket
            const bucketId = this.extractBucketId(extras, memberId);
            const bucketValue = bucketId.value;
            if (!bucketizers.children[bucketId.value]) {
                bucketizers.children[bucketId.value] = { current: builders[0](), children: {} };
            }
            const laterExtras = this.bucketizePart(quads, memberId, bucketizers.children[bucketId.value], builders.slice(1));
            // Try update our information about root buckets 
            const root = (_a = laterExtras.find(x => x.predicate.value === types_1.SDS.custom("isRoot") && x.object.value === "true")) === null || _a === void 0 ? void 0 : _a.subject;
            if (root) {
                bucketizers.children[bucketId.value].root = root;
            }
            // Reactively rewrite everything :(
            const extraBuckets = [
                this.extractBucketId(laterExtras, memberId),
                ...laterExtras
                    .filter(x => x.predicate.value === types_1.SDS.relation)
                    .flatMap(x => [x.subject, laterExtras.find(q => q.subject.equals(x.object) && q.predicate.value === types_1.SDS.relationBucket).object])
            ];
            if (extraBuckets.some(x => x.termType !== "NamedNode")) {
                console.error("Actually I only want named nodes here");
            }
            //  REMOVE MY SHITTY SDS RECORD
            const recordId = extras.find(x => x.predicate.value === types_1.SDS.payload && x.object.value === memberId).subject;
            extras = extras.filter(x => !x.subject.equals(recordId));
            const mapTerm = (x) => {
                const isRoot = x.equals(bucketizers.children[bucketValue].root);
                if (isRoot) {
                    return bucketId;
                }
                const matched = extraBuckets.find(q => q.equals(x));
                if (matched) {
                    switch (x.termType) {
                        case "NamedNode":
                            return this.factory.namedNode(bucketValue + '/' + x.value);
                        case "BlankNode":
                            return this.factory.blankNode(bucketValue + '/' + x.value);
                    }
                    throw "Expected only NamedNode or BlankNode to be mapped";
                }
                else {
                    return x;
                }
            };
            extras.push(...laterExtras.filter(x => !x.predicate.equals(types_1.SDS.terms.custom("isRoot"))).map(q => this.factory.quad(mapTerm(q.subject), q.predicate, mapTerm(q.object), q.graph)));
        }
        return extras;
    }
    importState(_state) {
    }
    ;
    exportState() {
    }
    ;
}
exports.MultiBucketizer = MultiBucketizer;
