
let [D_TEXT_ENCODER, D_TEXT_DECODER]
	= 'undefined' === typeof Buffer
		? ('undefined' === typeof TextEncoder
			? [new (require('util').TextEncoder)(), new (require('util').TextDecoder)()]  // eslint-disable-line global-require
			: [new TextEncoder(), new TextDecoder()])
		: [{encode:s => Buffer.from(s, 'utf-8')}, {decode:at => Buffer.from(at).toString('utf-8')}];


const AT_UTF_16_TOKEN = new Uint8Array([0xfe]);

const X_ENCODING_TYPED_ARRAY_INT8 = 0x11;
const X_ENCODING_TYPED_ARRAY_UINT8 = 0x21;
const X_ENCODING_TYPED_ARRAY_UINT8_CLAMPED = 0x31;
const X_ENCODING_TYPED_ARRAY_INT16 = 0x12;
const X_ENCODING_TYPED_ARRAY_UINT16 = 0x22;
const X_ENCODING_TYPED_ARRAY_INT32 = 0x14;
const X_ENCODING_TYPED_ARRAY_UINT32 = 0x24;
const X_ENCODING_TYPED_ARRAY_FLOAT32 = 0x44;
const X_ENCODING_TYPED_ARRAY_FLOAT64 = 0x48;
const X_ENCODING_TYPED_ARRAY_BIGINT64 = 0x58;
const X_ENCODING_TYPED_ARRAY_BIGUINT64 = 0x68;


const F_READ_0 = () => 0;
const F_READ_1 = (at, ib) => at[ib];
const F_WRITE_0 = (at, ib) => {
	at[ib] = 0;
	return at;
};
const F_WRITE_1 = (at, ib, x) => {
	at[ib] = x & 0xff;
	return at;
};



const H_FAST_READS_INT_BE = [
// 0 bytes
	F_READ_0,

// 1 byte
	F_READ_1,

	// 2 bytes
	(at, ib) => (at[ib] << 8) | at[ib+1],

	// 3 bytes
	(at, ib) => (at[ib] << 16) | (at[ib+1] << 8) | at[ib+2],

	// 4 bytes
	(at, ib) => (at[ib] << 24) | (at[ib+1] << 16) | (at[ib+2] << 8) | at[ib+3],
];

const H_FAST_READS_INT_LE = [
// 0 bytes
	F_READ_0,

// 1 byte
	F_READ_1,

	// 2 bytes
	(at, ib) => at[ib] | (at[ib+1] << 8),

	// 3 bytes
	(at, ib) => at[ib] | (at[ib+1] << 8) | (at[ib+2] << 16),

	// 4 bytes
	(at, ib) => at[ib] | (at[ib+1] << 8) | (at[ib+2] << 16) | (at[ib+3] << 24),
];


const H_FAST_WRITES_INT_BE = [
// 0 bytes
	F_WRITE_0,

// 1 byte
	F_WRITE_1,

	// 2 bytes
	(at, ib, x) => {
		at[ib] = (x >>> 8) & 0xff;
		at[ib+1] = x & 0xff;
		return at;
	},

	// 3 bytes
	(at, ib, x) => {
		at[ib] = (x >>> 16) & 0xff;
		at[ib+1] = (x >>> 8) & 0xff;
		at[ib+2] = x & 0xff;
		return at;
	},

	// 4 bytes
	(at, ib, x) => {
		at[ib] = (x >>> 24) & 0xff;
		at[ib+1] = (x >>> 16) & 0xff;
		at[ib+2] = (x >>> 8) & 0xff;
		at[ib+3] = x & 0xff;
		return at;
	},
];

const H_FAST_WRITES_INT_LE = [
// 0 bytes
	F_WRITE_0,

// 1 byte
	F_WRITE_1,

	// 2 bytes
	(at, ib, x) => {
		at[ib] = x & 0xff;
		at[ib+1] = (x >>> 8) & 0xff;
		return at;
	},

	// 3 bytes
	(at, ib, x) => {
		at[ib] = x & 0xff;
		at[ib+1] = (x >>> 8) & 0xff;
		at[ib+2] = (x >>> 16) & 0xff;
		return at;
	},

	// 4 bytes
	(at, ib, x) => {
		at[ib] = x & 0xff;
		at[ib+1] = (x >>> 8) & 0xff;
		at[ib+2] = (x >>> 16) & 0xff;
		at[ib+3] = (x >>> 24) & 0xff;
		return at;
	},
];


const H_FAST_READS_UINT_BE = [
// 0 bytes
	F_READ_0,

// 1 byte
	F_READ_1,

	// 2 bytes
	H_FAST_READS_INT_BE[2],

	// 3 bytes
	H_FAST_READS_INT_BE[3],

	// 4 bytes
	(at, ib) => (at[ib] * 0x1000000) + (at[ib+1] << 16) + (at[ib+2] << 8) + at[ib+3],

	// 5 bytes
	(at, ib) => (at[ib] * 0x100000000) + (at[ib+1] * 0x1000000) + (at[ib+2] << 16) + (at[ib+3] << 8) + at[ib+4],

	// 6 bytes
	(at, ib) => (at[ib] * 0x10000000000) + (at[ib+1] * 0x100000000) + (at[ib+2] * 0x1000000) + (at[ib+3] << 16) + (at[ib+4] << 8) + at[ib+5],

	// 7 bytes
	(at, ib) => (at[ib] * 0x1000000000000) + (at[ib+1] * 0x10000000000) + (at[ib+2] * 0x100000000) + (at[ib+3] * 0x1000000) + (at[ib+4] << 16) + (at[ib+5] << 8) + at[ib+6],
];

const H_FAST_READS_UINT_LE = [
// 0 bytes
	F_READ_0,

// 1 byte
	F_READ_1,

	// 2 bytes
	H_FAST_READS_INT_LE[2],

	// 3 bytes
	H_FAST_READS_INT_LE[3],

	// 4 bytes
	(at, ib) => at[ib] + (at[ib+1] << 8) + (at[ib+2] << 16) + (at[ib+3] * 0x1000000),

	// 5 bytes
	(at, ib) => at[ib] + (at[ib+1] << 8) + (at[ib+2] << 16) + (at[ib+3] * 0x1000000) + (at[ib+4] * 0x100000000),

	// 6 bytes
	(at, ib) => at[ib] + (at[ib+1] << 8) + (at[ib+2] << 16) + (at[ib+3] * 0x1000000) + (at[ib+4] * 0x100000000) + (at[ib+5] * 0x10000000000),

	// 7 bytes
	(at, ib) => at[ib] + (at[ib+1] << 8) + (at[ib+2] << 16) + (at[ib+3] * 0x1000000) + (at[ib+4] * 0x100000000) + (at[ib+5] * 0x10000000000) + (at[ib+6] * 0x1000000000000),
];

const H_FAST_WRITES_UINT_BE = [
// 0 bytes
	F_WRITE_0,

// 1 byte
	F_WRITE_1,

	// 2 bytes
	H_FAST_WRITES_INT_BE[2],

	// 3 bytes
	H_FAST_WRITES_INT_BE[3],

	// 4 bytes
	(at, ib, x) => {
		at[ib] = (x / 0x1000000) & 0xff;
		at[ib+1] = (x >>> 16) & 0xff;
		at[ib+2] = (x >>> 8) & 0xff;
		at[ib+3] = x & 0xff;
		return at;
	},

	// 5 bytes
	(at, ib, x) => {
		at[ib] = (x / 0x100000000) & 0xff;
		at[ib+1] = (x / 0x1000000) & 0xff;
		at[ib+2] = (x >>> 16) & 0xff;
		at[ib+3] = (x >>> 8) & 0xff;
		at[ib+4] = x & 0xff;
		return at;
	},

	// 6 bytes
	(at, ib, x) => {
		at[ib] = (x / 0x10000000000) & 0xff;
		at[ib+1] = (x / 0x100000000) & 0xff;
		at[ib+2] = (x / 0x1000000) & 0xff;
		at[ib+3] = (x >>> 16) & 0xff;
		at[ib+4] = (x >>> 8) & 0xff;
		at[ib+5] = x & 0xff;
		return at;
	},

	// 7 bytes
	(at, ib, x) => {
		at[ib] = (x / 0x1000000000000) & 0xff;
		at[ib+1] = (x / 0x10000000000) & 0xff;
		at[ib+2] = (x / 0x100000000) & 0xff;
		at[ib+3] = (x / 0x1000000) & 0xff;
		at[ib+4] = (x >>> 16) & 0xff;
		at[ib+5] = (x >>> 8) & 0xff;
		at[ib+6] = x & 0xff;
		return at;
	},
];

const H_FAST_WRITES_UINT_LE = [
// 0 bytes
	F_WRITE_0,

// 1 byte
	F_WRITE_1,

	// 2 bytes
	H_FAST_WRITES_INT_LE[2],

	// 3 bytes
	H_FAST_WRITES_INT_LE[3],

	// 4 bytes
	(at, ib, x) => {
		at[ib] = x & 0xff;
		at[ib+1] = (x >>> 8) & 0xff;
		at[ib+2] = (x >>> 16) & 0xff;
		at[ib+3] = (x / 0x1000000) & 0xff;
		return at;
	},

	// 5 bytes
	(at, ib, x) => {
		at[ib] = x & 0xff;
		at[ib+1] = (x >>> 8) & 0xff;
		at[ib+2] = (x >>> 16) & 0xff;
		at[ib+3] = (x / 0x1000000) & 0xff;
		at[ib+4] = (x / 0x100000000) & 0xff;
		return at;
	},

	// 6 bytes
	(at, ib, x) => {
		at[ib] = x & 0xff;
		at[ib+1] = (x >>> 8) & 0xff;
		at[ib+2] = (x >>> 16) & 0xff;
		at[ib+3] = (x / 0x1000000) & 0xff;
		at[ib+4] = (x / 0x100000000) & 0xff;
		at[ib+5] = (x / 0x10000000000) & 0xff;
		return at;
	},

	// 7 bytes
	(at, ib, x) => {
		at[ib] = x & 0xff;
		at[ib+1] = (x >>> 8) & 0xff;
		at[ib+2] = (x >>> 16) & 0xff;
		at[ib+3] = (x / 0x1000000) & 0xff;
		at[ib+4] = (x / 0x100000000) & 0xff;
		at[ib+5] = (x / 0x10000000000) & 0xff;
		at[ib+6] = (x / 0x1000000000000) & 0xff;
		return at;
	},
];



module.exports = {
	// popcount for uint32s
	popcount_uint32(x) {
		x -= (x >> 1) & 0x55555555;
		x = (x & 0x33333333) + ((x >> 2) & 0x33333333);
		return ((x + (x >> 4) & 0xf0f0f0f) * 0x1010101) >> 24;
	},

	// popcount for uint16s
	popcount_uint16(x) {
		x -= (x >>> 1) & 0x5555;
		x = (x & 0x3333) + ((x >>> 2) & 0x3333);
		return ((x + (x >>> 4) & 0xf0f) * 0x1010101) >>> 24;
	},

	// select1 lo for up to uint32s
	select1_lo_uint32(x, i_1) {
		let ii_pos = -1;
		while(i_1 >= 0 && x) {
			i_1 -= x & 1;
			x >>>= 1;
			ii_pos += 1;
		}
		return ii_pos;
	},

	// select1 hi on uint16s
	select1_hi_uint16(xu16_value, i_1) {
		let ii_pos = -1;
		while(i_1 >= 0 && xu16_value) {
			i_1 -= xu16_value & 0x8000;
			xu16_value <<= 1;
			ii_pos += 1;
		}
		return ii_pos;
	},


	D_TEXT_ENCODER,
	D_TEXT_DECODER,
	AT_UTF_16_TOKEN,

	X_ENCODING_TYPED_ARRAY_INT8,
	X_ENCODING_TYPED_ARRAY_UINT8,
	X_ENCODING_TYPED_ARRAY_UINT8_CLAMPED,
	X_ENCODING_TYPED_ARRAY_INT16,
	X_ENCODING_TYPED_ARRAY_UINT16,
	X_ENCODING_TYPED_ARRAY_INT32,
	X_ENCODING_TYPED_ARRAY_UINT32,
	X_ENCODING_TYPED_ARRAY_FLOAT32,
	X_ENCODING_TYPED_ARRAY_FLOAT64,
	X_ENCODING_TYPED_ARRAY_BIGINT64,
	X_ENCODING_TYPED_ARRAY_BIGUINT64,

	H_ENCODING_TO_TYPED_ARRAY: {
		[X_ENCODING_TYPED_ARRAY_INT8]: Int8Array,
		[X_ENCODING_TYPED_ARRAY_UINT8]: Uint8Array,
		[X_ENCODING_TYPED_ARRAY_UINT8_CLAMPED]: Uint8ClampedArray,
		[X_ENCODING_TYPED_ARRAY_INT16]: Int16Array,
		[X_ENCODING_TYPED_ARRAY_UINT16]: Uint16Array,
		[X_ENCODING_TYPED_ARRAY_INT32]: Int32Array,
		[X_ENCODING_TYPED_ARRAY_UINT32]: Uint32Array,
		[X_ENCODING_TYPED_ARRAY_FLOAT32]: Float32Array,
		[X_ENCODING_TYPED_ARRAY_FLOAT64]: Float64Array,
		[X_ENCODING_TYPED_ARRAY_BIGINT64]: BigInt64Array,
		[X_ENCODING_TYPED_ARRAY_BIGUINT64]: BigUint64Array,
	},

	H_FAST_READS_INT_BE,
	H_FAST_READS_INT_LE,
	H_FAST_WRITES_INT_BE,
	H_FAST_WRITES_INT_LE,

	H_FAST_READS_UINT_BE,
	H_FAST_READS_UINT_LE,
	H_FAST_WRITES_UINT_BE,
	H_FAST_WRITES_UINT_LE,
};
