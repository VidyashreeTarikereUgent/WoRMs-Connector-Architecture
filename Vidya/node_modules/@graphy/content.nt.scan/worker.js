
const run = sjx_eval => eval(sjx_eval);

// iiaf to isolate scope from eval
(function() {
	// queueMicrotask shim
	{
		// not defined or not a function
		if('function' !== typeof queueMicrotask) {
			// create resolved promise
			let dp_resolve = Promise.resolve();

			// try to redefine
			try {
				// eslint-disable-next-line no-global-assign
				queueMicrotask = fk => dp_resolve.then(fk)
					.catch(e_callback => setTimeout(() => {
						throw e_callback;
					}, 0));
			}
			// oh well, at least we tried
			catch(e_define) {}
		}
	}



	const reader = require('@graphy/content.nt.read');
	const threads = require('@graphy/core.iso.threads');

	// fast 4 byte reader from bkit
	const f_reader_uintle32 = (at, ib) => at[ib] + (at[ib+1] << 8) + (at[ib+2] << 16) + (at[ib+3] * 0x1000000);

	// fast 4 byte writer from bkit
	const f_writer_uintle32 = (at, ib, x) => {
		at[ib] = x & 0xff;
		at[ib+1] = (x >>> 8) & 0xff;
		at[ib+2] = (x >>> 16) & 0xff;
		at[ib+3] = (x / 0x1000000) & 0xff;
		return at;
	};


	const N_MISSES = 32;

	let parent;

	// flag to prevent softlock when posting error message to parent
	let b_suicide = false;

	// submit report to master thread
	function submit(w_value) {
		try {
			parent.postMessage({
				type: 'submit',
				value: w_value,
			});
		}
		catch(e_post) {
			parent.postMessage({
				type: 'clone-error',
				value: {
					info: 'submit()',
					object: w_value+'',
					error: e_post.stack || e_post.toString(),
				},
			});
		}
	}

	// send an update event to the master thread
	function update(w_msg, a_transfer) {
		try {
			parent.postMessage({
				type: 'update',
				value: w_msg,
			}, a_transfer);
		}
		catch(e_post) {
			parent.postMessage({
				type: 'clone-error',
				value: {
					info: 'update()',
					object: w_msg+'',
					error: e_post.stack || e_post.toString(),
				},
			});
		}
	}

	// throw an error to the master thread
	function err(e_what) {
		// proper error instance
		if(e_what instanceof Error) {
			// export
			parent.postMessage({
				type: 'error',
				value: {
					constructor: e_what.constructor.name,
					message: e_what.message,
					string: e_what+'',
					stack: e_what.stack || '',
				},
			});
		}
		// invalid error type
		else {
			// try sending the message
			try {
				parent.postMessage({
					type: 'throw',
					value: e_what,
				});
			}
			// could not serialize e_what
			catch(e_post) {
				// clone error
				parent.postMessage({
					type: 'clone-error',
					value: {
						info: 'err()',
						object: e_what+'',
						error: e_post.stack || e_post.toString(),
					},
				});
			}
		}

		// suicide
		b_suicide = true;
	}


	threads.worker(async(g_spawn) => {
		parent = g_spawn.parentPort;

		let {
			workerData: {
				si_content,
				sjx_run,
				nl_workers,
				nl_slots,
				nb_slot,
				// nb_region,
				at32_indicators,
				atu8_slot_owners,
				atu8_data,
				i_worker,
				w_user,
			},
		} = g_spawn;

		// catch uncaight exceptions and send to master thread
		process.on('uncaughtException', err);

		let f_run = run(`(${sjx_run})`);  // eslint-disable-line no-new-func


		// instantiate content reader
		let ds_reader = await f_run(reader, err, update, submit, w_user, true);

		// received eof from master thread; end content reader
		function eof() {
			ds_reader.end();
		}


// console.warn(`worker ${i_worker} indicator type: ${at32_indicator.buffer.toString()}`);

		// read slot data
		function read_slot(i_slot, xc_indicator) {
			// read data
			let ib_chunk = i_slot * nb_slot;

			// read chunk size
			let nb_chunk = f_reader_uintle32(atu8_data, ib_chunk);

			// fetch chunk
			let atu8_chunk = atu8_data.subarray(ib_chunk+4, ib_chunk+4+nb_chunk);

			// extract contents
			let ab_chunk = Buffer.from(atu8_chunk.buffer, atu8_chunk.byteOffset, nb_chunk);
			let s_chunk = ab_chunk.toString('utf8');

// log(`reading: ${nb_chunk} bytes (${s_chunk.length} characters)...`);

			// read contents
			ds_reader.write(s_chunk, 'utf8', () => {
// log(`read ${s_chunk.length} characters!`);

				// set ok status
				f_writer_uintle32(atu8_data, ib_chunk, 0);

				// bad slot owner
				if(i_worker !== atu8_slot_owners[i_slot]) {
					return err(new Error(`worker ${i_worker} encountered over-written slot owner ${atu8_slot_owners[i_slot]} (#${xc_indicator}/${at32_indicators[0]})`));
				}

				// return slot to main thread
				atu8_slot_owners[i_slot] = 0;

				// set indicator & notify
				Atomics.add(at32_indicators, 1, 1);
				Atomics.notify(at32_indicators, 1);

// log(`returned slot ${i_slot}`);

				// search again
				search();
			});
		}

		// search slots
		function search() {
			// chunk indicator
			let xc_indicator = Atomics.load(at32_indicators, 0);

			// search for open slot
			SLOT_SEARCH:
			for(let c_miss=0; c_miss<N_MISSES; c_miss++) {
				// each slot
				for(let i_slot=0; i_slot<nl_slots; i_slot++) {
					let i_owner = atu8_slot_owners[i_slot];

					// found slot ready for reading
					if(255 === i_owner) {
						// safe lock
						let xc_owner_prev = Atomics.compareExchange(atu8_slot_owners, i_slot, 255, i_worker);

						// failed to lock slot
						if(255 !== xc_owner_prev) {
							continue SLOT_SEARCH;
						}

// c_claimed += 1;

// log(`locked slot ${i_slot}: ${atu8_slot_owners[i_slot]} (claim #${c_claimed++} by this worker)`);

						// read slot
						return read_slot(i_slot, xc_indicator);
					}
					else {
					// log(`skipping slot ${i_slot}, owner is: ${atu8_slot_owners[i_slot]}`);
					}
				}
			}

			// escape recursion
			queueMicrotask(() => {
				// eof signal
				if(-1 === at32_indicators[0]) return eof();

				// wait until main thread has filled another slot
				let s_status = Atomics.wait(at32_indicators, 0, xc_indicator, 4000);

				// suicide; do not repeat search
				if(b_suicide) return;

			// // worker notified
			// log(`notified wake: ${s_status} => ${Atomics.load(at32_indicators, 0)}`);

				// try again
				search();
			});
		}

		// start search
		search();
	});
})();
