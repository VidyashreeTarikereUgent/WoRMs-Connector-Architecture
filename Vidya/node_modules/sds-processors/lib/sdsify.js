var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { Logger, RDF as RDFT, SDS } from "@treecg/types";
import { blankNode, namedNode } from "./core.js";
import { Writer as NWriter, Parser, DataFactory, Store } from "n3";
const logger = new Logger("info", "info");
class Tracker {
    constructor(max) {
        this.at = 0;
        this.logged = 0;
        this.max = max;
    }
    inc() {
        this.at += 1;
        let at = Math.round(this.at * 100 / this.max);
        if (at > this.logged) {
            console.log(at, "%");
            this.logged = at;
        }
    }
}
function maybe_parse(data) {
    if (typeof data === 'string' || data instanceof String) {
        const parse = new Parser();
        return parse.parse(data);
    }
    else {
        return data;
    }
}
function extractMember(store, subject) {
    const subGraph = [];
    // Extract forward relations recursively
    // TODO: deal with backwards relations
    // TODO: deal with cycles
    for (const quad of store.getQuads(subject, null, null, null)) {
        if (quad.object.termType === "NamedNode" || quad.object.termType === "BlankNode") {
            subGraph.push(...extractMember(store, quad.object));
        }
        subGraph.push(quad);
    }
    return subGraph;
}
export function sdsify(input, output, stream, type) {
    const streamNode = namedNode(stream);
    input.data((input) => __awaiter(this, void 0, void 0, function* () {
        const quads = maybe_parse(input);
        console.log("sdsify: Got input", quads.length, "quads");
        logger.info("sdsisfy got input!");
        const types = quads.filter(x => x.predicate.equals((RDFT.terms.type))).map(x => x.object.value).join(", ");
        logger.info("Found types " + types);
        const members = {};
        if (type) {
            logger.info("Extracting with type " + type);
            // Group quads based on given member type
            const store = new Store(quads);
            for (const quad of store.getQuads(null, RDFT.terms.type, namedNode(type), null)) {
                logger.info("Found one!");
                console.log("Found one!");
                members[quad.subject.value] = extractMember(store, quad.subject);
            }
        }
        else {
            // Group quads based on Subject IRI
            for (let quad of quads) {
                if (!members[quad.subject.value]) {
                    members[quad.subject.value] = [];
                }
                members[quad.subject.value].push(quad);
            }
        }
        let membersCount = 0;
        let first = true;
        for (let key of Object.keys(members)) {
            const quads = members[key];
            if (first) {
                first = false;
                console.log("predicates", quads.map(q => q.predicate.value));
            }
            const blank = blankNode();
            quads.push(DataFactory.quad(blank, SDS.terms.payload, namedNode(key)), DataFactory.quad(blank, SDS.terms.stream, streamNode));
            const str = new NWriter().quadsToString(quads);
            yield output.push(str);
            membersCount += 1;
        }
        console.log("sdsify: pushed ", membersCount, "members");
    }));
    input.on("end", () => {
        console.log("sdsify closed down");
        output.end();
    });
}
