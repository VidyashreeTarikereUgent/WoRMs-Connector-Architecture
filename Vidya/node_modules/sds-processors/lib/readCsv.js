var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { SDS, XSD } from "@treecg/types";
import { parse } from "csv-parse";
import { createReadStream } from "fs";
import { DataFactory, Quad } from "n3";
import { blankNode } from "./core.js";
import { join } from "path";
const { namedNode, literal, quad } = DataFactory;
function createTimedOutPusher(things, sw, onSend) {
    return setTimeout(() => {
        setInterval(() => __awaiter(this, void 0, void 0, function* () {
            const thing = things.shift();
            if (thing) {
                const foobar = onSend ? onSend(thing) : thing;
                yield sw.data.push(foobar);
            }
        }), 1000);
    }, 2000);
}
function readCsv(location, handler) {
    const cwd = process.cwd();
    return new Promise(res => {
        createReadStream(join(cwd, location))
            .pipe(parse({ delimiter: ",", fromLine: 2 }))
            .on("data", handler)
            .on("close", () => {
            res(undefined);
        });
    });
}
export function readCsvAsRDF(location, data) {
    const sw = { data };
    let headers = ["x", "y"];
    const things = [];
    createTimedOutPusher(things, sw, (things) => [...things, new Quad(things[0].subject, namedNode("http://example.org/ns#time"), literal(new Date().toISOString(), XSD.terms.dateTime))]);
    const handler = (data) => __awaiter(this, void 0, void 0, function* () {
        const out = [];
        const id = namedNode("http://example.org/id/" + Math.random());
        for (let i = 0; i < Math.min(data.length, headers.length); i++) {
            out.push(new Quad(id, namedNode("http://example.org/ns#" + headers[i]), literal(data[i])));
        }
        const newId = blankNode();
        out.push(quad(newId, SDS.terms.payload, id));
        out.push(quad(newId, SDS.terms.stream, namedNode("http://me#csvStream")));
        things.push(out);
    });
    readCsv(location, handler);
}
export function readCsvFile(location, data) {
    const sw = { data };
    let headers = ["x", "y"];
    const things = [];
    createTimedOutPusher(things, sw);
    const handler = (data) => {
        const out = {};
        for (let i = 0; i < Math.min(data.length, headers.length); i++) {
            out[headers[i]] = data[i];
        }
        things.push(out);
    };
    readCsv(location, handler);
}
