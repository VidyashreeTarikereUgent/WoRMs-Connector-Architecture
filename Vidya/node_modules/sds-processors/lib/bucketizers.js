var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { FACTORY } from "@treecg/bucketizers";
import { writeFileSync } from "fs";
import { readFile } from "fs/promises";
import { Parser, DataFactory } from "n3";
import * as N3 from "n3";
import { literal, transformMetadata } from "./core.js";
import { LDES, PPLAN, PROV, RDF, SDS } from "@treecg/types";
const { namedNode, quad } = DataFactory;
function readState(path) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const str = yield readFile(path, { "encoding": "utf-8" });
            return JSON.parse(str);
        }
        catch (e) {
            return;
        }
    });
}
function writeState(path, content) {
    return __awaiter(this, void 0, void 0, function* () {
        if (path) {
            const str = JSON.stringify(content);
            writeFileSync(path, str, { encoding: "utf-8" });
        }
    });
}
function addProcess(id, store, strategyId, bucketizeConfig) {
    const newId = store.createBlankNode();
    const time = new Date().getTime();
    store.addQuad(newId, RDF.terms.type, PPLAN.terms.Activity);
    store.addQuad(newId, RDF.terms.type, LDES.terms.Bucketization);
    store.addQuads(bucketizeConfig);
    store.addQuad(newId, PROV.terms.startedAtTime, literal(time));
    store.addQuad(newId, PROV.terms.used, strategyId);
    if (id)
        store.addQuad(newId, PROV.terms.used, id);
    return newId;
}
function parseQuads(quads) {
    if (quads instanceof Array)
        return quads;
    console.log("Parsing quads!", quads);
    const parser = new N3.Parser();
    return parser.parse(quads);
}
function serializeQuads(quads) {
    const writer = new N3.Writer();
    return writer.quadsToString(quads);
}
export function doTheBucketization(dataReader, metadataReader, dataWriter, metadataWriter, location, savePath, sourceStream, resultingStream) {
    return __awaiter(this, void 0, void 0, function* () {
        dataReader.on("end", () => {
            console.log("bucketize data closed");
            dataWriter.end();
        });
        metadataReader.on("end", () => { console.log("buckeitze index closed"); metadataWriter.end(); });
        const sr = { metadata: metadataReader, data: dataReader };
        const sw = { metadata: metadataWriter, data: dataWriter };
        const content = yield readFile(location, { encoding: "utf-8" });
        console.log("content", content);
        const quads = new Parser().parse(content);
        const quadMemberId = quads.find(quad => quad.predicate.equals(RDF.terms.type) && quad.object.equals(LDES.terms.BucketizeStrategy)).subject;
        console.log("Do bucketization", quadMemberId);
        const f = transformMetadata(namedNode(resultingStream), sourceStream ? namedNode(sourceStream) : undefined, "sds:Member", (x, y) => addProcess(x, y, quadMemberId, quads));
        sr.metadata.data(quads => sw.metadata.push(serializeQuads(f(parseQuads(quads)))));
        if (sr.metadata.lastElement) {
            sw.metadata.push(serializeQuads(f(parseQuads(sr.metadata.lastElement))));
        }
        const state = yield readState(savePath);
        const bucketizer = FACTORY.buildLD(quads, quadMemberId, state);
        if (state)
            bucketizer.importState(state);
        // Cleanup(async () => {
        //     const state = bucketizer.exportState()
        //     await writeState(savePath, state);
        // })
        sr.data.data((data) => __awaiter(this, void 0, void 0, function* () {
            const t = parseQuads(data);
            console.log("Bucketizing member");
            if (!t.length)
                return;
            const checkStream = sourceStream ? (q) => t.some(q2 => q2.subject.equals(q.subject) && q2.predicate.equals(SDS.terms.stream) && q2.object.value === sourceStream) : (_) => true;
            const members = [...new Set(t.filter(q => q.predicate.equals(SDS.terms.custom("payload")) && checkStream(q)).map(q => q.object))];
            if (members.length > 1) {
                console.error("Detected more members ids than expected");
            }
            if (members.length === 0)
                return;
            const sub = members[0].value;
            const extras = bucketizer.bucketize(t, sub);
            const recordId = extras.find(q => q.predicate.equals(SDS.terms.payload)).subject;
            t.push(...extras);
            t.push(quad(recordId, SDS.terms.stream, namedNode(resultingStream)));
            t.push(quad(recordId, RDF.terms.type, SDS.terms.Member));
            console.log("Pushing thing bucketized!");
            yield sw.data.push(serializeQuads(t));
        }));
    });
}
